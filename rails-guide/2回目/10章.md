# 10章
## コントローラの肥大化
コントローラは全体的なイーズの増大から複雑になりやすい。

### モデルに書くべきコードをモデルに寄せる。
|どんなコードか|モデルに寄せるためのテクニック例|
|---|---|
|多少変わった形のparamsからの代入コード|paramsの形を標準的にしたり、モデル側に適切な受け口（代入口）を作った上で、一括代入で済ませる。|
|オブジェクトの内部状態を変更するコード（代入・処理の呼び出し）|before_saveなどのコールバックを利用したり、統合的なメソッドを追加する|
|モデルの検索条件を作り込むコード|scopeを定義する|
|モデルを操作するために必要な情報を揃えるための準備的な処理|モデルの操作のところに合わせて担当させるか、必要情報を表すモデルを新設してデータを揃える処理を担当させる。|
```ruby
@user.zip_code = params[:zip1].present? && params[:zip2].present? ? [params[:zip1], params[:zip2]].join('-') : nil
```
params[:zip1]とparams[:zip2]にあたいが渡されていたならば、params[:zip1]とparams[:zip2]を'-'でくっつける。もし条件を満たしていなければnilを返す。

## 共通機能のモジュールを複数のモデルクラスにMix-inする
共通化したい機能を記述したモジュールを作り、そのモジュールを複数のモデルクラスからincludeする。
includeはインスタンスメソッドとして呼び出される。インスタンスメソッドは、インスタンスに対して呼び出すことができるメソッド。
extencはクラスメソッドとして呼び出すことができる。クラスメソッドはクラス名.メソッドという形で呼び出すことができる。

## STI(単一テーブル継承)
継承関係にある一連のモデルクラスを全て一つのテーブルに対応づける。安易に継承を利用しすぎると、維持コストが上がってしまったりするため、注意が必要。

## コントローラの共通化
コントローラに関してもモジュールによる共通化が行える。モジュールの配置場所はapp/controllers/concerns。
共通化は次の内容がほぼ同じであるようなアクションについてだけ行う。
・処理で利用するインスタンス変数
・ビューテンプレート
・主な関心ごとに対応するモデル
・パラメータ
・セッションへの操作

## ActiveModel
モデルの便利な機能を普通のクラスで実現することをサポートしてくれるモジュール群。
ActiveModel::Attributes
ActiveModel::Attributesは非常にシンプルに、属性（attributes）の型の指定と変換を行ってくれる。

## モジュールを上手に活用する
モジュールを利用する際に以下の原則を念頭に置く。
### 構造としてわかりやすい意味を持たせる。
意味のまとまりを考えずに適当にメソッドをモジュールに切り出してしまうと、何がどこにあるという知識の整理が行われず、混沌とした状態になってしまう。
### 利用元クラスの一部として違和感がないかを検討する。
include/extendしたメソッドは元々そのクラスで実装されていたかのように扱われる。そのため、モジュールを作成するときは、そのモジュール全体がinclude先のクラスの振る舞いとして違和感がないかどうかを検討するとうまくいく。
### 利用元クラスと内部データを共有していることを意識する。
モジュールで定義するふるまいが利用する内部データ（インスタンス変数）は、クラスやそのクラスが利用している他のモジュールと共有しているということを念頭に置くようにする。

### 独立的にして利用条件をわかりやすくする。
モジュールを他のモジュールと関連づけて利用するなどの制約があると、実装しようとするときにどのモジュールをセットで使わなければならないのかを把握しなければならないため、モジュールは基本的に独立的に作成する。

### 追加部品であるという節度を守る。
クラスに想定される自然な挙動を大きく変更するような場合は、そのためのコードをクラスに直接書いたり、モジュールの利用者に向けて強い注意喚起を促すといった工夫をしていく必要がある。





