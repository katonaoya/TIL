# 1章
## インスタンスオブジェクト
クラスに従属するオブジェクトをインスタンスオブジェクトという

## クラスを作る意味
意味的な共通性のあるデータを一つのオブジェクトに集約して扱えるようにクラスを作る。

## インスタンス変数
オブジェクトが保持する変数。

## attr_accessor
```ruby
# インスタンス変数を代入するメソッドをセッターという
def name=(name)
  @name = name
end
# インスタンス変数の内容を参照するためのメソッドをゲッターという
def name
  @name
end
```
user = User.new
user.name = "ken"
とすると、パーソンオブジェクトの持つ@nameに"ken"が入る。

```ruby
attr_accessor :name
```
とすると、nameのセッターとゲッターを両方定義することと同義になる。

attr_readerでゲッターだけ、attr_writerでセッターだけを定義することができる。

## if
elseがない場合はnilオブジェクトを返す。
コードの後ろにifを置く後置if文はifの条件だったらそれより前のコードを実行する。ただし、else等の複雑な文章はかけない。

## シンボル
シンボルは何かしらの名前を表す存在

## ハッシュ
ハッシュないの全てのキーを得るにはkeys
              全ての値　を得るにはvalues

## initialize
オブジェクトをnewメソッドで生成する時に、そのオブジェクトのinitializeメソッドが実行される。
initializeに引数をとるクラスのオブジェクトを作成するときは、newに対応する引数を渡す。
```ruby
class User
  attr_reader :name, :address, :email
  def initialize(name, address, email)
    @name = name
    @address = address
    @email = email
  end
end
user = User.new("名前", "住所", "メールアドレス")
```
initializeメソッドは自動的にprivateメソッドになる。

## module
モジュールはクラスと同じ様にインスタンスメソッドを定義することができるが、オブジェクトを生成することができない。モジュールで定義したメソッドは、様々なクラスで使うことができる。

## nilガード
```ruby
number ||= 10
```
とすると、numberがtrueであればnumberをそのまま使う。numberがnil（またはfalse）であれば10を代入する。

## ぼっち演算子
&.という演算子を使ってメソッドを呼び出すと、レシーバがnil出会った場合もエラーが発生しなくなります。

## %記法
```ruby
ary1 = %i(apple banana orange)
p ary1
=> ["apple", "banana", "orange"]

ary2 = %i(apple banana orange)
p ary2
=> [:apple, :banana, :orange]
```
ソースコードを減らすことで、可読性を高めることができる。

## map
mapメソッドは配列の各要素に対してブロックを実行した結果を格納した新しい配列を返します。
```ruby
class User
  attr_accessor :name
end

user1 = User.new
user1.name = '桃太郎'
user2 = User.new
user2.name = '浦島太郎'
user3 = User.new
user3.name = '金太郎'

names = []
users.map do |user|
  names << user.name
end
p names
=> ["桃太郎", "浦島太郎", "金太郎"]

names = users.map do |user|
  user.name
end
=> ["桃太郎", "浦島太郎", "金太郎"]

names = user.map { |user| user.name }
=> ["桃太郎", "浦島太郎", "金太郎"]

names = user.map(&:name)
=> ["桃太郎", "浦島太郎", "金太郎"]
```


